const path = require('path'),
    assert = require('assert'),
    package = require(path.resolve('package.json')),
    cliColors = {
        RED: '\033[31m',
        GREEN: '\033[32m',
        NONE: '\033[0m'
    };
console.log('Yet', package.version, 'Tests suite');

let stopOnFail = false;
let startFrom = null, startedFrom = false;
let testSpecificSuites = null;

process.argv.forEach((arg, index) => {

    switch (true) {
    case arg === '-stopOnFail':
        stopOnFail = true;
        break;
    case arg.indexOf('-startFrom=') === 0:
        startFrom = arg.split('=', 2)[1].trim();
        break;
    case arg.indexOf('-suites=') === 0:
        testSpecificSuites = arg.split('=', 2)[1].split(',');
        break;
    }
});

const runnerConfig = package.config['test-runner'];
const testSuites = [];

runnerConfig.suites.forEach((name) => {
    try {
        let suite = require(name);

        if (testSpecificSuites) {
            let testSuiteIndex = testSpecificSuites.indexOf(suite.name);
            if (testSuiteIndex == -1) {
                return;
            }
            testSpecificSuites.splice(testSuiteIndex, 1);
        }

        testSuites.push(suite);
    } catch (e) {
        console.error(cliColors.RED + 'Suite `' + name + '` loading error:\n', e, cliColors.NONE);
    }
});

if (testSpecificSuites && testSpecificSuites.length) {
    console.warn(cliColors.RED + 'Warning: Suites not found:', testSpecificSuites.join(', '));
}


let passes = 0;
let failures = 0;
let executedTests = 0;
const execution = [];

testSuites.forEach((suite, suiteIndex) => {
    try {
        let tests = suite.tests;
        if (tests instanceof Object && !(tests instanceof Array)) {
            tests = Object.keys(tests).map((test) => { return tests[test]});
        }
        execution.push((done) => {
            console.log('\nSuite:', suite.name, '-', tests.length, 'tests.');
            done();
        });
        tests.forEach((test, testIndex) => {
            let testName = (test.name || '<undefined>').replace(/(_)/g, ' '),
                testId = ['S', suiteIndex, 'T', testIndex].join('');
            if (startFrom && !startedFrom) {
                if (testId != startFrom) {
                    return;
                } else {
                    startedFrom = true;
                }
            }
            execution.push((done) => {
                executedTests++;
                var afterTest;
                var doneTest = (err) => {
                    doneTest = () => {
                        throw new Error('Done test is already called for test ' + testName);
                    };
                    if (err) {
                        failures++;
                        console.error(cliColors.RED + '[FAIL]', '-', testName, '\nError:', err, cliColors.NONE);
                        if (!err.stack) {
                            console.trace();
                        }
                        if (stopOnFail) {
                            console.error('- Test suite was run in `stopOnFailure` module.')
                            console.error('- To re-run suite from failed test execute:');
                            if (startFrom) {
                                console.error(process.argv.join(' '));
                            } else {
                                console.error(process.argv.join(' ') + ' -startFrom=' + testId);
                            }
                            process.exit(1);
                        }
                    } else {
                        passes++;
                        console.log(cliColors.GREEN + '[PASS]', cliColors.NONE + '-', testName);
                    }
                    if (typeof afterTest == 'function') {
                        afterTest(err);
                    }
                    done(err);
                };

                if (test.length) {
                    var timeout;
                    var doneAsyncTest = (err) => {
                        clearTimeout(timeout);
                        doneTest(err);
                    };
                    timeout = setTimeout(() => {
                        doneAsyncTest('Test timeout after ' + runnerConfig.timeout + ' ms.');
                    }, runnerConfig.timeout);
                    doneAsyncTest.tryStatement = (statement, args) => {
                        try {
                            if (args) {
                                statement.apply(this, args);
                            } else {
                                statement();
                            }
                            doneAsyncTest();
                        } catch (err) {
                            doneAsyncTest(err);
                        }
                    };
                    doneAsyncTest.ok = () => {
                        doneAsyncTest();
                    };
                    doneAsyncTest.try = (statement) => {
                        return function () {
                            doneAsyncTest.tryStatement(statement, arguments);
                        };
                    };
                    try {
                        doneAsyncTest.fail = (err) => {
                            doneAsyncTest('Failure: ' + err.stack || 'unknown reason');
                        };
                        afterTest = test(doneAsyncTest);
                    } catch (err) {
                        doneAsyncTest(err);
                    }
                } else {
                    try {
                        afterTest = test();
                        doneTest();
                    } catch (err) {
                        doneTest(err);
                    }
                }

            });
        });
    } catch (err) {
        console.error('Suite:', suite.name, 'error:\n', err);
    }
});

const onExecutionCompleted = () => {
        console.log('\n----------------------------------------');
        if (failures) {
            console.error('Found', '(' + failures + '/' + executedTests + ')', 'test failures');
            process.exit(1);
        } else {
            console.log('Tests', '(' + executedTests + ')', 'passed OK');
            process.exit(0);
        }
    },
    executeNext = () => {
        setTimeout(function () {
            if (!execution.length) {
                onExecutionCompleted();
            } else {
                var currentExecution = execution.shift();
                currentExecution(executeNext);
            }
        }, 1);
    };

executeNext();
